{"version":3,"file":"content.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://doc-detective-browser/./node_modules/@medv/finder/finder.js","webpack://doc-detective-browser/webpack/bootstrap","webpack://doc-detective-browser/webpack/runtime/define property getters","webpack://doc-detective-browser/webpack/runtime/hasOwnProperty shorthand","webpack://doc-detective-browser/webpack/runtime/make namespace object","webpack://doc-detective-browser/./src/content.js"],"sourcesContent":["var Limit;\n(function (Limit) {\n    Limit[Limit[\"All\"] = 0] = \"All\";\n    Limit[Limit[\"Two\"] = 1] = \"Two\";\n    Limit[Limit[\"One\"] = 2] = \"One\";\n})(Limit || (Limit = {}));\nlet config;\nlet rootDocument;\nexport function finder(input, options) {\n    if (input.nodeType !== Node.ELEMENT_NODE) {\n        throw new Error(`Can't generate CSS selector for non-element node type.`);\n    }\n    if (\"html\" === input.tagName.toLowerCase()) {\n        return \"html\";\n    }\n    const defaults = {\n        root: document.body,\n        idName: (name) => true,\n        className: (name) => true,\n        tagName: (name) => true,\n        attr: (name, value) => false,\n        seedMinLength: 1,\n        optimizedMinLength: 2,\n        threshold: 1000,\n        maxNumberOfTries: 10000,\n    };\n    config = Object.assign(Object.assign({}, defaults), options);\n    rootDocument = findRootDocument(config.root, defaults);\n    let path = bottomUpSearch(input, Limit.All, () => bottomUpSearch(input, Limit.Two, () => bottomUpSearch(input, Limit.One)));\n    if (path) {\n        const optimized = sort(optimize(path, input));\n        if (optimized.length > 0) {\n            path = optimized[0];\n        }\n        return selector(path);\n    }\n    else {\n        throw new Error(`Selector was not found.`);\n    }\n}\nfunction findRootDocument(rootNode, defaults) {\n    if (rootNode.nodeType === Node.DOCUMENT_NODE) {\n        return rootNode;\n    }\n    if (rootNode === defaults.root) {\n        return rootNode.ownerDocument;\n    }\n    return rootNode;\n}\nfunction bottomUpSearch(input, limit, fallback) {\n    let path = null;\n    let stack = [];\n    let current = input;\n    let i = 0;\n    while (current && current !== config.root.parentElement) {\n        let level = maybe(id(current)) ||\n            maybe(...attr(current)) ||\n            maybe(...classNames(current)) ||\n            maybe(tagName(current)) || [any()];\n        const nth = index(current);\n        if (limit === Limit.All) {\n            if (nth) {\n                level = level.concat(level.filter(dispensableNth).map((node) => nthChild(node, nth)));\n            }\n        }\n        else if (limit === Limit.Two) {\n            level = level.slice(0, 1);\n            if (nth) {\n                level = level.concat(level.filter(dispensableNth).map((node) => nthChild(node, nth)));\n            }\n        }\n        else if (limit === Limit.One) {\n            const [node] = (level = level.slice(0, 1));\n            if (nth && dispensableNth(node)) {\n                level = [nthChild(node, nth)];\n            }\n        }\n        for (let node of level) {\n            node.level = i;\n        }\n        stack.push(level);\n        if (stack.length >= config.seedMinLength) {\n            path = findUniquePath(stack, fallback);\n            if (path) {\n                break;\n            }\n        }\n        current = current.parentElement;\n        i++;\n    }\n    if (!path) {\n        path = findUniquePath(stack, fallback);\n    }\n    return path;\n}\nfunction findUniquePath(stack, fallback) {\n    const paths = sort(combinations(stack));\n    if (paths.length > config.threshold) {\n        return fallback ? fallback() : null;\n    }\n    for (let candidate of paths) {\n        if (unique(candidate)) {\n            return candidate;\n        }\n    }\n    return null;\n}\nfunction selector(path) {\n    let node = path[0];\n    let query = node.name;\n    for (let i = 1; i < path.length; i++) {\n        const level = path[i].level || 0;\n        if (node.level === level - 1) {\n            query = `${path[i].name} > ${query}`;\n        }\n        else {\n            query = `${path[i].name} ${query}`;\n        }\n        node = path[i];\n    }\n    return query;\n}\nfunction penalty(path) {\n    return path.map((node) => node.penalty).reduce((acc, i) => acc + i, 0);\n}\nfunction unique(path) {\n    switch (rootDocument.querySelectorAll(selector(path)).length) {\n        case 0:\n            throw new Error(`Can't select any node with this selector: ${selector(path)}`);\n        case 1:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction id(input) {\n    const elementId = input.getAttribute(\"id\");\n    if (elementId && config.idName(elementId)) {\n        return {\n            name: \"#\" + cssesc(elementId, { isIdentifier: true }),\n            penalty: 0,\n        };\n    }\n    return null;\n}\nfunction attr(input) {\n    const attrs = Array.from(input.attributes).filter((attr) => config.attr(attr.name, attr.value));\n    return attrs.map((attr) => ({\n        name: \"[\" +\n            cssesc(attr.name, { isIdentifier: true }) +\n            '=\"' +\n            cssesc(attr.value) +\n            '\"]',\n        penalty: 0.5,\n    }));\n}\nfunction classNames(input) {\n    const names = Array.from(input.classList).filter(config.className);\n    return names.map((name) => ({\n        name: \".\" + cssesc(name, { isIdentifier: true }),\n        penalty: 1,\n    }));\n}\nfunction tagName(input) {\n    const name = input.tagName.toLowerCase();\n    if (config.tagName(name)) {\n        return {\n            name,\n            penalty: 2,\n        };\n    }\n    return null;\n}\nfunction any() {\n    return {\n        name: \"*\",\n        penalty: 3,\n    };\n}\nfunction index(input) {\n    const parent = input.parentNode;\n    if (!parent) {\n        return null;\n    }\n    let child = parent.firstChild;\n    if (!child) {\n        return null;\n    }\n    let i = 0;\n    while (child) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            i++;\n        }\n        if (child === input) {\n            break;\n        }\n        child = child.nextSibling;\n    }\n    return i;\n}\nfunction nthChild(node, i) {\n    return {\n        name: node.name + `:nth-child(${i})`,\n        penalty: node.penalty + 1,\n    };\n}\nfunction dispensableNth(node) {\n    return node.name !== \"html\" && !node.name.startsWith(\"#\");\n}\nfunction maybe(...level) {\n    const list = level.filter(notEmpty);\n    if (list.length > 0) {\n        return list;\n    }\n    return null;\n}\nfunction notEmpty(value) {\n    return value !== null && value !== undefined;\n}\nfunction* combinations(stack, path = []) {\n    if (stack.length > 0) {\n        for (let node of stack[0]) {\n            yield* combinations(stack.slice(1, stack.length), path.concat(node));\n        }\n    }\n    else {\n        yield path;\n    }\n}\nfunction sort(paths) {\n    return Array.from(paths).sort((a, b) => penalty(a) - penalty(b));\n}\nfunction* optimize(path, input, scope = {\n    counter: 0,\n    visited: new Map(),\n}) {\n    if (path.length > 2 && path.length > config.optimizedMinLength) {\n        for (let i = 1; i < path.length - 1; i++) {\n            if (scope.counter > config.maxNumberOfTries) {\n                return; // Okay At least I tried!\n            }\n            scope.counter += 1;\n            const newPath = [...path];\n            newPath.splice(i, 1);\n            const newPathKey = selector(newPath);\n            if (scope.visited.has(newPathKey)) {\n                return;\n            }\n            if (unique(newPath) && same(newPath, input)) {\n                yield newPath;\n                scope.visited.set(newPathKey, true);\n                yield* optimize(newPath, input, scope);\n            }\n        }\n    }\n}\nfunction same(path, input) {\n    return rootDocument.querySelector(selector(path)) === input;\n}\nconst regexAnySingleEscape = /[ -,\\.\\/:-@\\[-\\^`\\{-~]/;\nconst regexSingleEscape = /[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/;\nconst regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\nconst defaultOptions = {\n    escapeEverything: false,\n    isIdentifier: false,\n    quotes: \"single\",\n    wrap: false,\n};\nfunction cssesc(string, opt = {}) {\n    const options = Object.assign(Object.assign({}, defaultOptions), opt);\n    if (options.quotes != \"single\" && options.quotes != \"double\") {\n        options.quotes = \"single\";\n    }\n    const quote = options.quotes == \"double\" ? '\"' : \"'\";\n    const isIdentifier = options.isIdentifier;\n    const firstChar = string.charAt(0);\n    let output = \"\";\n    let counter = 0;\n    const length = string.length;\n    while (counter < length) {\n        const character = string.charAt(counter++);\n        let codePoint = character.charCodeAt(0);\n        let value = void 0;\n        // If it’s not a printable ASCII character…\n        if (codePoint < 0x20 || codePoint > 0x7e) {\n            if (codePoint >= 0xd800 && codePoint <= 0xdbff && counter < length) {\n                // It’s a high surrogate, and there is a next character.\n                const extra = string.charCodeAt(counter++);\n                if ((extra & 0xfc00) == 0xdc00) {\n                    // next character is low surrogate\n                    codePoint = ((codePoint & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                }\n                else {\n                    // It’s an unmatched surrogate; only append this code unit, in case\n                    // the next code unit is the high surrogate of a surrogate pair.\n                    counter--;\n                }\n            }\n            value = \"\\\\\" + codePoint.toString(16).toUpperCase() + \" \";\n        }\n        else {\n            if (options.escapeEverything) {\n                if (regexAnySingleEscape.test(character)) {\n                    value = \"\\\\\" + character;\n                }\n                else {\n                    value = \"\\\\\" + codePoint.toString(16).toUpperCase() + \" \";\n                }\n            }\n            else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n                value = \"\\\\\" + codePoint.toString(16).toUpperCase() + \" \";\n            }\n            else if (character == \"\\\\\" ||\n                (!isIdentifier &&\n                    ((character == '\"' && quote == character) ||\n                        (character == \"'\" && quote == character))) ||\n                (isIdentifier && regexSingleEscape.test(character))) {\n                value = \"\\\\\" + character;\n            }\n            else {\n                value = character;\n            }\n        }\n        output += value;\n    }\n    if (isIdentifier) {\n        if (/^-[-\\d]/.test(output)) {\n            output = \"\\\\-\" + output.slice(1);\n        }\n        else if (/\\d/.test(firstChar)) {\n            output = \"\\\\3\" + firstChar + \" \" + output.slice(1);\n        }\n    }\n    // Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n    // since they’re redundant. Note that this is only possible if the escape\n    // sequence isn’t preceded by an odd number of backslashes.\n    output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {\n        if ($1 && $1.length % 2) {\n            // It’s not safe to remove the space, so don’t.\n            return $0;\n        }\n        // Strip the space.\n        return ($1 || \"\") + $2;\n    });\n    if (!isIdentifier && options.wrap) {\n        return quote + output + quote;\n    }\n    return output;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { finder } from \"@medv/finder\";\r\n\r\ndocument.addEventListener(\"click\", (event) => {\r\n  let dialog = document.getElementById(\"doc-detective\");\r\n  if (dialog) {\r\n    const selector = finder(event.target);\r\n    // Loop to identify if selector is part of main page\r\n    let inDialog = false;\r\n    let elements = [];\r\n    elements[0] = document.querySelector(selector);\r\n    for (let i = 0; i < elements.length; i++) {\r\n      let element = elements[i];\r\n      let parent = element.parentElement;\r\n      let parentName = parent.nodeName.toLowerCase();\r\n      if (parentName !== \"body\") {\r\n        elements.push(parent);\r\n        continue;\r\n      }\r\n      if (\r\n        parentName === \"body\" &&\r\n        element.nodeName.toLowerCase() === \"div\" &&\r\n        element.id === \"doc-detective\"\r\n      ) {\r\n        inDialog = true;\r\n      }\r\n    }\r\n    // Exit early if click is in the dialog\r\n    if (inDialog) return;\r\n    let selectorDisplay = document.getElementById(\"selectorDisplay\");\r\n    event.stopPropagation();\r\n    event.preventDefault();\r\n    selectorDisplay.innerHTML = selector;\r\n  }\r\n});\r\n\r\nfunction copySelector() {\r\n  // Get the text field\r\n  var copyText = document.getElementById(\"selectorDisplay\");\r\n\r\n  // Select the text field\r\n  copyText.select();\r\n  copyText.setSelectionRange(0, 99999); // For mobile devices\r\n\r\n  // Copy the text inside the text field\r\n  navigator.clipboard.writeText(copyText.value);\r\n\r\n  // Alert the copied text\r\n  alert(\"Copied the text: \" + copyText.value);\r\n}\r\n"],"names":[],"sourceRoot":""}